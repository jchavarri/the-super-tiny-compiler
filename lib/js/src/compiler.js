// Generated by BUCKLESCRIPT VERSION 1.9.3, PLEASE EDIT WITH CARE
'use strict';

var Char        = require("bs-platform/lib/js/char.js");
var List        = require("bs-platform/lib/js/list.js");
var Block       = require("bs-platform/lib/js/block.js");
var $$String    = require("bs-platform/lib/js/string.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");

function explode(s) {
  var _i = s.length - 1 | 0;
  var _l = /* [] */0;
  while(true) {
    var l = _l;
    var i = _i;
    if (i < 0) {
      return l;
    } else {
      _l = /* :: */[
        Caml_string.get(s, i),
        l
      ];
      _i = i - 1 | 0;
      continue ;
      
    }
  };
}

function tokenizer(input) {
  var _input = explode(input);
  var _current = /* None */0;
  var _tokens = /* [] */0;
  var _state = /* Init */0;
  while(true) {
    var state = _state;
    var tokens = _tokens;
    var current = _current;
    var input$1 = _input;
    if (input$1) {
      var i = input$1[0];
      var exit = 0;
      var exit$1 = 0;
      var exit$2 = 0;
      var switcher = i - 32 | 0;
      if (switcher > 9 || switcher < 0) {
        exit$2 = 3;
      } else {
        switch (switcher) {
          case 0 : 
              if (current) {
                var s = current[0];
                var xi = input$1[1];
                switch (state) {
                  case 0 : 
                      exit$1 = 2;
                      break;
                  case 1 : 
                      _state = /* Init */0;
                      _tokens = /* :: */[
                        s,
                        tokens
                      ];
                      _current = /* None */0;
                      _input = xi;
                      continue ;
                      case 2 : 
                      exit$2 = 3;
                      break;
                  case 3 : 
                      if (typeof s === "number") {
                        exit$1 = 2;
                      } else if (s.tag === 2) {
                        _state = /* Init */0;
                        _tokens = /* :: */[
                          /* Name */Block.__(2, [s[0]]),
                          tokens
                        ];
                        _current = /* None */0;
                        _input = xi;
                        continue ;
                        
                      } else {
                        exit$1 = 2;
                      }
                      break;
                  
                }
              } else {
                exit$1 = 2;
              }
              break;
          case 2 : 
              var xi$1 = input$1[1];
              if (current) {
                var match = current[0];
                if (typeof match === "number") {
                  return List.rev(tokens);
                } else if (match.tag === 1) {
                  if (state !== 2) {
                    return List.rev(tokens);
                  } else {
                    _state = /* Init */0;
                    _tokens = /* :: */[
                      /* String */Block.__(1, [match[0]]),
                      tokens
                    ];
                    _current = /* None */0;
                    _input = xi$1;
                    continue ;
                    
                  }
                } else {
                  return List.rev(tokens);
                }
              } else if (state !== 0) {
                return List.rev(tokens);
              } else {
                _state = /* ParsingString */2;
                _current = /* Some */[/* String */Block.__(1, [""])];
                _input = xi$1;
                continue ;
                
              }
              break;
          case 1 : 
          case 3 : 
          case 4 : 
          case 5 : 
          case 6 : 
          case 7 : 
              exit$2 = 3;
              break;
          case 8 : 
              if (current) {
                exit$2 = 3;
              } else if (state !== 0) {
                return List.rev(tokens);
              } else {
                _state = /* Init */0;
                _tokens = /* :: */[
                  /* OpenParen */0,
                  tokens
                ];
                _current = /* None */0;
                _input = input$1[1];
                continue ;
                
              }
              break;
          case 9 : 
              var xi$2 = input$1[1];
              if (current) {
                if (state !== 0) {
                  switch (state - 1 | 0) {
                    case 0 : 
                        _state = /* Init */0;
                        _tokens = /* :: */[
                          /* CloseParen */1,
                          /* :: */[
                            current[0],
                            tokens
                          ]
                        ];
                        _current = /* None */0;
                        _input = xi$2;
                        continue ;
                        case 1 : 
                        exit$2 = 3;
                        break;
                    case 2 : 
                        return List.rev(tokens);
                    
                  }
                } else {
                  return List.rev(tokens);
                }
              } else if (state !== 0) {
                return List.rev(tokens);
              } else {
                _state = /* Init */0;
                _tokens = /* :: */[
                  /* CloseParen */1,
                  tokens
                ];
                _current = /* None */0;
                _input = xi$2;
                continue ;
                
              }
              break;
          
        }
      }
      if (exit$2 === 3) {
        if (current) {
          var match$1 = current[0];
          if (typeof match$1 === "number") {
            exit$1 = 2;
          } else if (match$1.tag === 1) {
            if (state !== 2) {
              exit$1 = 2;
            } else {
              _state = /* ParsingString */2;
              _current = /* Some */[/* String */Block.__(1, [match$1[0] + Char.escaped(i)])];
              _input = input$1[1];
              continue ;
              
            }
          } else {
            exit$1 = 2;
          }
        } else {
          exit$1 = 2;
        }
      }
      if (exit$1 === 2) {
        if (i >= 32) {
          if (i < 58) {
            if (i >= 33) {
              if (i >= 48) {
                var xi$3 = input$1[1];
                if (current) {
                  var match$2 = current[0];
                  if (typeof match$2 === "number") {
                    return List.rev(tokens);
                  } else if (match$2.tag) {
                    return List.rev(tokens);
                  } else if (state !== 1) {
                    return List.rev(tokens);
                  } else {
                    _state = /* ParsingNumber */1;
                    _current = /* Some */[/* Number */Block.__(0, [match$2[0] + Char.escaped(i)])];
                    _input = xi$3;
                    continue ;
                    
                  }
                } else if (state !== 0) {
                  return List.rev(tokens);
                } else {
                  _state = /* ParsingNumber */1;
                  _current = /* Some */[/* Number */Block.__(0, [Char.escaped(i)])];
                  _input = xi$3;
                  continue ;
                  
                }
              } else {
                return List.rev(tokens);
              }
            } else {
              exit = 1;
            }
          } else if (i > 122 || i < 97) {
            return List.rev(tokens);
          } else {
            var xi$4 = input$1[1];
            if (current) {
              var match$3 = current[0];
              if (typeof match$3 === "number") {
                return List.rev(tokens);
              } else if (match$3.tag === 2) {
                if (state >= 3) {
                  _state = /* ParsingName */3;
                  _current = /* Some */[/* Name */Block.__(2, [match$3[0] + Char.escaped(i)])];
                  _input = xi$4;
                  continue ;
                  
                } else {
                  return List.rev(tokens);
                }
              } else {
                return List.rev(tokens);
              }
            } else if (state !== 0) {
              return List.rev(tokens);
            } else {
              _state = /* ParsingName */3;
              _current = /* Some */[/* Name */Block.__(2, [Char.escaped(i)])];
              _input = xi$4;
              continue ;
              
            }
          }
        } else if (i >= 11) {
          if (i !== 13) {
            return List.rev(tokens);
          } else {
            exit = 1;
          }
        } else if (i >= 9) {
          exit = 1;
        } else {
          return List.rev(tokens);
        }
      }
      if (exit === 1) {
        if (current) {
          return List.rev(tokens);
        } else if (state !== 0) {
          return List.rev(tokens);
        } else {
          _state = /* Init */0;
          _current = /* None */0;
          _input = input$1[1];
          continue ;
          
        }
      }
      
    } else {
      return List.rev(tokens);
    }
  };
}

function parser(tokens) {
  var _tokens = tokens;
  var _stack = /* [] */0;
  var _program = /* [] */0;
  while(true) {
    var program = _program;
    var stack = _stack;
    var tokens$1 = _tokens;
    var exit = 0;
    if (tokens$1) {
      var match = tokens$1[0];
      if (typeof match === "number") {
        if (match) {
          if (stack) {
            _program = /* :: */[
              stack[0],
              program
            ];
            _stack = stack[1];
            _tokens = tokens$1[1];
            continue ;
            
          } else {
            exit = 1;
          }
        } else {
          var match$1 = tokens$1[1];
          if (match$1) {
            var match$2 = match$1[0];
            if (typeof match$2 === "number") {
              if (stack) {
                return /* Error */Block.__(1, ["Unmatched opened and closed parenthesis"]);
              } else {
                exit = 1;
              }
            } else if (match$2.tag === 2) {
              _stack = /* :: */[
                /* CallExpression */Block.__(2, [
                    match$2[0],
                    /* [] */0
                  ]),
                stack
              ];
              _tokens = match$1[1];
              continue ;
              
            } else if (stack) {
              return /* Error */Block.__(1, ["Unmatched opened and closed parenthesis"]);
            } else {
              exit = 1;
            }
          } else if (stack) {
            return /* Error */Block.__(1, ["Unmatched opened and closed parenthesis"]);
          } else {
            exit = 1;
          }
        }
      } else {
        switch (match.tag | 0) {
          case 0 : 
              if (stack) {
                var match$3 = stack[0];
                switch (match$3.tag | 0) {
                  case 0 : 
                  case 1 : 
                      if (stack) {
                        return /* Error */Block.__(1, ["Unmatched opened and closed parenthesis"]);
                      } else {
                        exit = 1;
                      }
                      break;
                  case 2 : 
                      _stack = /* :: */[
                        /* CallExpression */Block.__(2, [
                            match$3[0],
                            /* :: */[
                              /* NumberLiteral */Block.__(0, [match[0]]),
                              match$3[1]
                            ]
                          ]),
                        stack[1]
                      ];
                      _tokens = tokens$1[1];
                      continue ;
                      
                }
              } else {
                exit = 1;
              }
              break;
          case 1 : 
              if (stack) {
                var match$4 = stack[0];
                switch (match$4.tag | 0) {
                  case 0 : 
                  case 1 : 
                      if (stack) {
                        return /* Error */Block.__(1, ["Unmatched opened and closed parenthesis"]);
                      } else {
                        exit = 1;
                      }
                      break;
                  case 2 : 
                      _stack = /* :: */[
                        /* CallExpression */Block.__(2, [
                            match$4[0],
                            /* :: */[
                              /* StringLiteral */Block.__(1, [match[0]]),
                              match$4[1]
                            ]
                          ]),
                        stack[1]
                      ];
                      _tokens = tokens$1[1];
                      continue ;
                      
                }
              } else {
                exit = 1;
              }
              break;
          case 2 : 
              if (stack) {
                return /* Error */Block.__(1, ["Unmatched opened and closed parenthesis"]);
              } else {
                exit = 1;
              }
              break;
          
        }
      }
    } else if (stack) {
      if (stack) {
        return /* Error */Block.__(1, ["Unmatched opened and closed parenthesis"]);
      } else {
        exit = 1;
      }
    } else {
      return /* Ok */Block.__(0, [List.rev(program)]);
    }
    if (exit === 1) {
      var tmp = tokens$1[0];
      if (typeof tmp === "number") {
        if (tmp) {
          return /* Error */Block.__(1, ["Unexpected \"CloseParen\" token"]);
        } else {
          return /* Error */Block.__(1, ["Unexpected \"OpenParen\" token"]);
        }
      } else {
        switch (tmp.tag | 0) {
          case 0 : 
              return /* Error */Block.__(1, ["Unexpected \"Number\" token"]);
          case 1 : 
              return /* Error */Block.__(1, ["Unexpected \"String\" token"]);
          case 2 : 
              return /* Error */Block.__(1, ["Unexpected \"Name\" token"]);
          
        }
      }
    }
    
  };
}

function debugToken(token) {
  if (typeof token === "number") {
    if (token) {
      return "CloseParen";
    } else {
      return "OpenParen";
    }
  } else {
    switch (token.tag | 0) {
      case 0 : 
          return "Number " + token[0];
      case 1 : 
          return "String " + token[0];
      case 2 : 
          return "Name " + token[0];
      
    }
  }
}

function debugAstNode(astNode) {
  switch (astNode.tag | 0) {
    case 0 : 
        return $$String.concat("", /* :: */[
                    "Number",
                    /* :: */[
                      astNode[0],
                      /* :: */[
                        " ",
                        /* [] */0
                      ]
                    ]
                  ]);
    case 1 : 
        return $$String.concat("", /* :: */[
                    "String",
                    /* :: */[
                      astNode[0],
                      /* :: */[
                        " ",
                        /* [] */0
                      ]
                    ]
                  ]);
    case 2 : 
        return $$String.concat(" ", /* :: */[
                    "CallExpression",
                    /* :: */[
                      astNode[0],
                      /* :: */[
                        List.fold_left((function (acc, x) {
                                return debugAstNode(x) + acc;
                              }), "", astNode[1]),
                        /* [] */0
                      ]
                    ]
                  ]);
    
  }
}

var test = parser(tokenizer("(add 2 (subtract 4 2))"));

List.iter((function (k) {
        console.log(debugToken(k));
        return /* () */0;
      }), tokenizer("(add 2 (subtract 4 2))"));

var parsePrinted;

parsePrinted = test.tag ? "Error at parse stage: " + test[0] : List.fold_left((function (acc, x) {
          return debugAstNode(x) + acc;
        }), "", test[0]);

console.log(parsePrinted);

var initialMachine = /* record */[
  /* current : None */0,
  /* parsedTokens : [] */0,
  /* state : Init */0
];

exports.initialMachine = initialMachine;
exports.explode        = explode;
exports.tokenizer      = tokenizer;
exports.parser         = parser;
exports.debugToken     = debugToken;
exports.debugAstNode   = debugAstNode;
exports.test           = test;
exports.parsePrinted   = parsePrinted;
/* test Not a pure module */

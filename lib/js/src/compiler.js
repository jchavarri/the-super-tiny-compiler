// Generated by BUCKLESCRIPT VERSION 1.9.3, PLEASE EDIT WITH CARE
'use strict';

var Char        = require("bs-platform/lib/js/char.js");
var List        = require("bs-platform/lib/js/list.js");
var Block       = require("bs-platform/lib/js/block.js");
var $$String    = require("bs-platform/lib/js/string.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");

function explode(s) {
  var _i = s.length - 1 | 0;
  var _l = /* [] */0;
  while(true) {
    var l = _l;
    var i = _i;
    if (i < 0) {
      return l;
    } else {
      _l = /* :: */[
        Caml_string.get(s, i),
        l
      ];
      _i = i - 1 | 0;
      continue ;
      
    }
  };
}

function tokenizer(input) {
  var _input = explode(input);
  var _current = /* None */0;
  var _tokens = /* [] */0;
  while(true) {
    var tokens = _tokens;
    var current = _current;
    var input$1 = _input;
    if (input$1) {
      var i = input$1[0];
      var exit = 0;
      var exit$1 = 0;
      var exit$2 = 0;
      var switcher = i - 32 | 0;
      if (switcher > 9 || switcher < 0) {
        exit$2 = 3;
      } else {
        switch (switcher) {
          case 0 : 
              if (current) {
                var match = current[0];
                var xi = input$1[1];
                if (typeof match === "number") {
                  exit$1 = 2;
                } else {
                  switch (match.tag | 0) {
                    case 0 : 
                        _tokens = /* :: */[
                          /* Number */Block.__(0, [match[0]]),
                          tokens
                        ];
                        _current = /* None */0;
                        _input = xi;
                        continue ;
                        case 1 : 
                        exit$2 = 3;
                        break;
                    case 2 : 
                        _tokens = /* :: */[
                          /* Name */Block.__(2, [match[0]]),
                          tokens
                        ];
                        _current = /* None */0;
                        _input = xi;
                        continue ;
                        
                  }
                }
              } else {
                exit$1 = 2;
              }
              break;
          case 2 : 
              var xi$1 = input$1[1];
              if (current) {
                var match$1 = current[0];
                if (typeof match$1 === "number") {
                  return List.rev(tokens);
                } else if (match$1.tag === 1) {
                  _tokens = /* :: */[
                    /* String */Block.__(1, [match$1[0]]),
                    tokens
                  ];
                  _current = /* None */0;
                  _input = xi$1;
                  continue ;
                  
                } else {
                  return List.rev(tokens);
                }
              } else {
                _current = /* Some */[/* String */Block.__(1, [""])];
                _input = xi$1;
                continue ;
                
              }
              break;
          case 1 : 
          case 3 : 
          case 4 : 
          case 5 : 
          case 6 : 
          case 7 : 
              exit$2 = 3;
              break;
          case 8 : 
              if (current) {
                exit$2 = 3;
              } else {
                _tokens = /* :: */[
                  /* OpenParen */0,
                  tokens
                ];
                _current = /* None */0;
                _input = input$1[1];
                continue ;
                
              }
              break;
          case 9 : 
              var xi$2 = input$1[1];
              if (current) {
                var match$2 = current[0];
                if (typeof match$2 === "number") {
                  return List.rev(tokens);
                } else {
                  switch (match$2.tag | 0) {
                    case 0 : 
                        _tokens = /* :: */[
                          /* CloseParen */1,
                          /* :: */[
                            /* Number */Block.__(0, [match$2[0]]),
                            tokens
                          ]
                        ];
                        _current = /* None */0;
                        _input = xi$2;
                        continue ;
                        case 1 : 
                        exit$2 = 3;
                        break;
                    case 2 : 
                        _tokens = /* :: */[
                          /* CloseParen */1,
                          /* :: */[
                            /* Name */Block.__(2, [match$2[0]]),
                            tokens
                          ]
                        ];
                        _current = /* None */0;
                        _input = xi$2;
                        continue ;
                        
                  }
                }
              } else {
                _tokens = /* :: */[
                  /* CloseParen */1,
                  tokens
                ];
                _current = /* None */0;
                _input = xi$2;
                continue ;
                
              }
              break;
          
        }
      }
      if (exit$2 === 3) {
        if (current) {
          var match$3 = current[0];
          if (typeof match$3 === "number") {
            exit$1 = 2;
          } else if (match$3.tag === 1) {
            _current = /* Some */[/* String */Block.__(1, [match$3[0] + Char.escaped(i)])];
            _input = input$1[1];
            continue ;
            
          } else {
            exit$1 = 2;
          }
        } else {
          exit$1 = 2;
        }
      }
      if (exit$1 === 2) {
        if (i >= 32) {
          if (i < 58) {
            if (i >= 33) {
              if (i >= 48) {
                var xi$3 = input$1[1];
                if (current) {
                  var match$4 = current[0];
                  if (typeof match$4 === "number") {
                    return List.rev(tokens);
                  } else if (match$4.tag) {
                    return List.rev(tokens);
                  } else {
                    _current = /* Some */[/* Number */Block.__(0, [match$4[0] + Char.escaped(i)])];
                    _input = xi$3;
                    continue ;
                    
                  }
                } else {
                  _current = /* Some */[/* Number */Block.__(0, [Char.escaped(i)])];
                  _input = xi$3;
                  continue ;
                  
                }
              } else {
                return List.rev(tokens);
              }
            } else {
              exit = 1;
            }
          } else if (i > 122 || i < 97) {
            return List.rev(tokens);
          } else {
            var xi$4 = input$1[1];
            if (current) {
              var match$5 = current[0];
              if (typeof match$5 === "number") {
                return List.rev(tokens);
              } else if (match$5.tag === 2) {
                _current = /* Some */[/* Name */Block.__(2, [match$5[0] + Char.escaped(i)])];
                _input = xi$4;
                continue ;
                
              } else {
                return List.rev(tokens);
              }
            } else {
              _current = /* Some */[/* Name */Block.__(2, [Char.escaped(i)])];
              _input = xi$4;
              continue ;
              
            }
          }
        } else if (i >= 11) {
          if (i !== 13) {
            return List.rev(tokens);
          } else {
            exit = 1;
          }
        } else if (i >= 9) {
          exit = 1;
        } else {
          return List.rev(tokens);
        }
      }
      if (exit === 1) {
        if (current) {
          return List.rev(tokens);
        } else {
          _current = /* None */0;
          _input = input$1[1];
          continue ;
          
        }
      }
      
    } else {
      return List.rev(tokens);
    }
  };
}

function parser(tokens) {
  var _tokens = tokens;
  var _stack = /* [] */0;
  var _program = /* [] */0;
  while(true) {
    var program = _program;
    var stack = _stack;
    var tokens$1 = _tokens;
    var exit = 0;
    if (tokens$1) {
      var match = tokens$1[0];
      if (typeof match === "number") {
        if (match) {
          if (stack) {
            _program = /* :: */[
              stack[0],
              program
            ];
            _stack = stack[1];
            _tokens = tokens$1[1];
            continue ;
            
          } else {
            exit = 1;
          }
        } else {
          var match$1 = tokens$1[1];
          if (match$1) {
            var match$2 = match$1[0];
            if (typeof match$2 === "number") {
              if (stack) {
                return /* Error */Block.__(1, ["Unmatched opened and closed parenthesis"]);
              } else {
                exit = 1;
              }
            } else if (match$2.tag === 2) {
              _stack = /* :: */[
                /* CallExpression */Block.__(2, [
                    match$2[0],
                    /* [] */0
                  ]),
                stack
              ];
              _tokens = match$1[1];
              continue ;
              
            } else if (stack) {
              return /* Error */Block.__(1, ["Unmatched opened and closed parenthesis"]);
            } else {
              exit = 1;
            }
          } else if (stack) {
            return /* Error */Block.__(1, ["Unmatched opened and closed parenthesis"]);
          } else {
            exit = 1;
          }
        }
      } else {
        switch (match.tag | 0) {
          case 0 : 
              if (stack) {
                var match$3 = stack[0];
                switch (match$3.tag | 0) {
                  case 0 : 
                  case 1 : 
                      if (stack) {
                        return /* Error */Block.__(1, ["Unmatched opened and closed parenthesis"]);
                      } else {
                        exit = 1;
                      }
                      break;
                  case 2 : 
                      _stack = /* :: */[
                        /* CallExpression */Block.__(2, [
                            match$3[0],
                            /* :: */[
                              /* NumberLiteral */Block.__(0, [match[0]]),
                              match$3[1]
                            ]
                          ]),
                        stack[1]
                      ];
                      _tokens = tokens$1[1];
                      continue ;
                      
                }
              } else {
                exit = 1;
              }
              break;
          case 1 : 
              if (stack) {
                var match$4 = stack[0];
                switch (match$4.tag | 0) {
                  case 0 : 
                  case 1 : 
                      if (stack) {
                        return /* Error */Block.__(1, ["Unmatched opened and closed parenthesis"]);
                      } else {
                        exit = 1;
                      }
                      break;
                  case 2 : 
                      _stack = /* :: */[
                        /* CallExpression */Block.__(2, [
                            match$4[0],
                            /* :: */[
                              /* StringLiteral */Block.__(1, [match[0]]),
                              match$4[1]
                            ]
                          ]),
                        stack[1]
                      ];
                      _tokens = tokens$1[1];
                      continue ;
                      
                }
              } else {
                exit = 1;
              }
              break;
          case 2 : 
              if (stack) {
                return /* Error */Block.__(1, ["Unmatched opened and closed parenthesis"]);
              } else {
                exit = 1;
              }
              break;
          
        }
      }
    } else if (stack) {
      if (stack) {
        return /* Error */Block.__(1, ["Unmatched opened and closed parenthesis"]);
      } else {
        exit = 1;
      }
    } else {
      return /* Ok */Block.__(0, [List.rev(program)]);
    }
    if (exit === 1) {
      var tmp = tokens$1[0];
      if (typeof tmp === "number") {
        if (tmp) {
          return /* Error */Block.__(1, ["Unexpected \"CloseParen\" token"]);
        } else {
          return /* Error */Block.__(1, ["Unexpected \"OpenParen\" token"]);
        }
      } else {
        switch (tmp.tag | 0) {
          case 0 : 
              return /* Error */Block.__(1, ["Unexpected \"Number\" token"]);
          case 1 : 
              return /* Error */Block.__(1, ["Unexpected \"String\" token"]);
          case 2 : 
              return /* Error */Block.__(1, ["Unexpected \"Name\" token"]);
          
        }
      }
    }
    
  };
}

function transformer(astList) {
  var transform = function (astNode, _transformedContext) {
    while(true) {
      var transformedContext = _transformedContext;
      switch (astNode.tag | 0) {
        case 0 : 
            if (transformedContext) {
              var match = transformedContext[0];
              if (match.tag === 2) {
                return /* TCallExpression */Block.__(2, [
                          match[0],
                          /* :: */[
                            /* TNumber */Block.__(0, [astNode[0]]),
                            match[1]
                          ]
                        ]);
              } else {
                return /* TString */Block.__(1, ["Error"]);
              }
            } else {
              return /* TString */Block.__(1, ["Error"]);
            }
            break;
        case 1 : 
            if (transformedContext) {
              var match$1 = transformedContext[0];
              if (match$1.tag === 2) {
                return /* TCallExpression */Block.__(2, [
                          match$1[0],
                          /* :: */[
                            /* TString */Block.__(1, [astNode[0]]),
                            match$1[1]
                          ]
                        ]);
              } else {
                return /* TString */Block.__(1, ["Error"]);
              }
            } else {
              return /* TString */Block.__(1, ["Error"]);
            }
            break;
        case 2 : 
            var l = astNode[1];
            if (transformedContext) {
              var match$2 = transformedContext[0];
              switch (match$2.tag | 0) {
                case 0 : 
                case 1 : 
                    return /* TString */Block.__(1, ["Error"]);
                case 2 : 
                    if (match$2[1]) {
                      return /* TString */Block.__(1, ["Error"]);
                    } else {
                      return /* TCallExpression */Block.__(2, [
                                match$2[0],
                                List.map((function(transformedContext){
                                    return function (n) {
                                      return transform(n, transformedContext);
                                    }
                                    }(transformedContext)), l)
                              ]);
                    }
                case 3 : 
                    var tce = match$2[0];
                    if (tce.tag === 2) {
                      if (tce[1]) {
                        return /* TString */Block.__(1, ["Error"]);
                      } else {
                        return /* TCallExpression */Block.__(2, [
                                  tce[0],
                                  List.map((function(tce){
                                      return function (n) {
                                        return transform(n, /* Some */[tce]);
                                      }
                                      }(tce)), l)
                                ]);
                      }
                    } else {
                      return /* TString */Block.__(1, ["Error"]);
                    }
                    break;
                
              }
            } else {
              _transformedContext = /* Some */[/* TExpressionStatement */Block.__(3, [/* TCallExpression */Block.__(2, [
                        /* Identifier */[astNode[0]],
                        /* [] */0
                      ])])];
              continue ;
              
            }
            break;
        
      }
    };
  };
  return List.map((function (x) {
                return transform(x, /* None */0);
              }), astList);
}

function debugToken(token) {
  if (typeof token === "number") {
    if (token) {
      return "CloseParen";
    } else {
      return "OpenParen";
    }
  } else {
    switch (token.tag | 0) {
      case 0 : 
          return "Number " + token[0];
      case 1 : 
          return "String " + token[0];
      case 2 : 
          return "Name " + token[0];
      
    }
  }
}

function debugAstNode(astNode) {
  switch (astNode.tag | 0) {
    case 0 : 
        return $$String.concat("", /* :: */[
                    "Number",
                    /* :: */[
                      astNode[0],
                      /* :: */[
                        " ",
                        /* [] */0
                      ]
                    ]
                  ]);
    case 1 : 
        return $$String.concat("", /* :: */[
                    "String",
                    /* :: */[
                      astNode[0],
                      /* :: */[
                        " ",
                        /* [] */0
                      ]
                    ]
                  ]);
    case 2 : 
        return $$String.concat(" ", /* :: */[
                    "CallExpression",
                    /* :: */[
                      astNode[0],
                      /* :: */[
                        List.fold_left((function (acc, x) {
                                return debugAstNode(x) + acc;
                              }), "", astNode[1]),
                        /* [] */0
                      ]
                    ]
                  ]);
    
  }
}

function debugTransformedAstNode(astNode, tabs) {
  switch (astNode.tag | 0) {
    case 0 : 
        return $$String.concat(tabs, /* :: */[
                    "\n",
                    /* :: */[
                      "Number: ",
                      /* :: */[
                        astNode[0],
                        /* [] */0
                      ]
                    ]
                  ]);
    case 1 : 
        return $$String.concat("\n", /* :: */[
                    tabs,
                    /* :: */[
                      "String: ",
                      /* :: */[
                        astNode[0],
                        /* [] */0
                      ]
                    ]
                  ]);
    case 2 : 
        return $$String.concat("\n", /* :: */[
                    tabs,
                    /* :: */[
                      "CallExpression",
                      /* :: */[
                        astNode[0][0],
                        /* :: */[
                          List.fold_left((function (acc, x) {
                                  return debugTransformedAstNode(x, tabs + "_") + acc;
                                }), "", astNode[1]),
                          /* [] */0
                        ]
                      ]
                    ]
                  ]);
    case 3 : 
        return $$String.concat("\n", /* :: */[
                    tabs,
                    /* :: */[
                      "ExpressionStatement: ",
                      /* [] */0
                    ]
                  ]);
    
  }
}

var test = parser(tokenizer("(add 2 (subtract 4 2))"));

var parsePrinted;

parsePrinted = test.tag ? "Error at parse stage: " + test[0] : List.fold_left((function (acc, x) {
          return debugAstNode(x) + acc;
        }), "\t", test[0]);

console.log(parsePrinted);

var testTransformer;

testTransformer = test.tag ? /* [] */0 : transformer(test[0]);

console.log(List.fold_left((function (acc, x) {
            return debugTransformedAstNode(x, "") + acc;
          }), "", testTransformer));

var machine = /* record */[
  /* current : None */0,
  /* parsed : [] */0
];

exports.machine                 = machine;
exports.explode                 = explode;
exports.tokenizer               = tokenizer;
exports.parser                  = parser;
exports.transformer             = transformer;
exports.debugToken              = debugToken;
exports.debugAstNode            = debugAstNode;
exports.debugTransformedAstNode = debugTransformedAstNode;
exports.test                    = test;
exports.parsePrinted            = parsePrinted;
exports.testTransformer         = testTransformer;
/* test Not a pure module */
